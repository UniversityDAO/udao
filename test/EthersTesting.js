const { ethers } = require("hardhat");

/*
    The purpose of this document is to create a testing environment for proposals
    and simulate what real voting may look like given 20 Hardhat testing accounts.
    The main() function contains calls to all of the below functions and is called on its own,
    so running this file by itself will simulate the testing environment. To run, do the following:
    1. Create a fresh Hardhat node. $ npx hardhat node
    2. Run the python auto-deploy script. $ python auto-deploy-script.py
    3. Run this file. $ npx hardhat run --network localhost EthersTesting.js
*/

const proposalCIDs = 
[
    'bafybeicemp7nuvbwvmi3xeyrtxvplyiabdchc3rqkzunjgcy6faljzmmpe', 
    'bafybeiahbaiznop3g6immxmapl5lvpiezcquqk4finn3y5p342k4pwcfve',
    'bafybeie23fhkbp2t2hugegjmc7o4zmf3t5qhw4frvquvgzfqrx6m3vpasq',
    'bafybeiedjiszwue27ev6cse4jmtz2dlwv26pmdyouzzfqu6lqs363qxeii',
    'bafybeigfsz4enuwgiipcmhoaflrktiizirck7trxnem4avodb72vwnpm3e',
    'bafybeiglfbgvqsqevcxoaperb3rkuffn22bjrq2ncnqzvxt5fdys2c27qq'
]

/*For the sake of testing:
  MembershipNFT address = 0x5FbDB2315678afecb367f032d93F642f64180aa3
  UDAOToken address = 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512
  Governor address = 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0
*/

/**
 * Grabs all 20 Hardhat accounts, and mints 1 NFT to each + delegates
 * voting power to each account.
 * This function must be called before proposals are generated, or else
 * accounts WILL NOT have any voting power during voting simulation
 */
 async function mintAndDelegate() {
    // Grab an instance of our MembershipNFT contract
    const membershipNFT = await ethers.getContractAt("MembershipNFT", "0x5FbDB2315678afecb367f032d93F642f64180aa3");
    await membershipNFT.deployed();

    // Get all 20 accounts generated by Hardhat
    let accounts;
    accounts = await ethers.getSigners();

    // Loop through all the accounts, give each one 1 NFT + delegate so they get voting power
    for(let a=0; a<accounts.length; a++){
        await membershipNFT.safeMint(accounts[a].address);
        await membershipNFT.connect(accounts[a]).delegate(accounts[a].address);
    }
}

/**
 * Creates 10 fake proposal objects to use in testing
 * All proposal data stored in the Governance contract
 * @returns {Promise<Array[]>} - Array of Proposal IDs
 */
async function generateMockProposals() {
    let proposalIDs = [];

    // Get an instance of our Governance contract
    const gov = await ethers.getContractAt("Governance", "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0");
    await gov.deployed();

    //Get an instance of our UDAO Token contract
    const tokenAddress = '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512'
    const token = await ethers.getContractAt('ERC20', tokenAddress);

    //Data to feed into our propose() function for hashing
    const teamAddress = '0x70997970C51812dc3A010C7d01b50e0d17dc79C8';
    const grantAmount = 10;
    const transferCalldata = token.interface.encodeFunctionData('transfer', [teamAddress, grantAmount]);

    //Create 10 mock proposals and push the IDs of each one into an array
    /*
    for (let i=0; i<10; i++) {
        const proposal = await gov.propose([tokenAddress], [i], [transferCalldata], "Hash goes here");
        const receipt = await proposal.wait();

        const proposalID = await receipt.events[0].args.proposalId;
        proposalIDs.push(proposalID);
    }*/
    for (let i=0; i<proposalCIDs.length; i++) {
        const proposal = await gov.propose([tokenAddress], [250], [transferCalldata], proposalCIDs[i]);
        const receipt = await proposal.wait();

        const proposalID = await receipt.events[0].args.proposalId;
        proposalIDs.push(proposalID);
    }

    //Return our array of ProposalIDs
    return proposalIDs;
}

/**
 * Simulates a voting environment to test voting functionality with ethers
 * At each of the 10 Proposals passed in, each of the 20 Hardhat
 *  accounts will vote once.
 * After all is done, every proposal should have 20 randomized votes 
 *  that are either yes or no (for or against)
 * @param {Array[]} proposalIds - Array of Proposal IDs that we want to vote for
 */
async function simulateVoting(proposalIds) {
    // Get an instance of our Governance contract
    const gov = await ethers.getContractAt("Governance", "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0");
    await gov.deployed();

    // Get all 20 accounts generated by Hardhat
    let accounts;
    accounts = await ethers.getSigners();

    let support, vote, receipt;

    // At every Proposal ID, all 20 accounts vote (doubly nested for loop)
    for(let p=0; p<proposalIds.length; p++){
        console.log(`Now Voting on ProposalID: ${proposalIds[p]}`);
        for(let a=0; a<accounts.length; a++){

            //Generate a random number signifying the vote, 0 for no, 1 for yes
            support = Math.round(Math.random());
            console.log(`   Account ${accounts[a].address} will vote ${support} for the proposal.`);
            
            //Cast vote and grab receipt
            vote = await gov.connect(accounts[a]).castVote(proposalIds[p], support);
            receipt = await vote.wait();

            console.log(`       Vote of ${receipt.events[0].args[2]} completed.`);
            console.log(`           Proposal Data after vote: ${await gov.proposalVotes(proposalIds[p])}`);
        }
    }
}

/**
 * Given an array argument of Proposal IDs,
 * create a new proposal object array containing the ID
 * of each proposal + the vote data for that proposal
 * @param {Array[]} proposalIds - Array of Proposal ID values (uint256 values)
 * @returns {Promise<Array[]>} - Array of proposal objects
 */
 async function getBlockchainData(proposalIds) {
    let proposals = [];

    // Get an instance of our Governance contract
    const gov = await ethers.getContractAt("Governance", "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0");

    // Create our own proposal objects with ID + vote counts
    let votes;
    for(let i=0; i<proposalIds.length; i++){
        votes = await gov.proposalVotes(proposalIds[i]);
        proposals.push({
            id: proposalIds[i],
            votes: votes    
        });
    }

    //Return all vote data
    return proposals;
}

async function main() {
    await mintAndDelegate();
    let proposalIds = await generateMockProposals();
    await simulateVoting(proposalIds);
    let props = await getBlockchainData(proposalIds);
    console.log(props);
}

main();
