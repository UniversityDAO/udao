const { ethers } = require("ethers");

/*For the sake of testing:
  MembershipNFT address = 0x5FbDB2315678afecb367f032d93F642f64180aa3
  UDAOToken address = 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512
  Governor address = 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0
*/

/**
 * Grabs all 20 Hardhat accounts, and mints 1 NFT to each + delegates
 * voting power to each account.
 * This function must be called before proposals are generated, or else
 * accounts WILL NOT have any voting power during voting simulation
 */
 async function mintAndDelegate() {
    // Grab an instance of our MembershipNFT contract
    const membershipNFT = await ethers.getContractAt("MembershipNFT", "0x5FbDB2315678afecb367f032d93F642f64180aa3");
    await membershipNFT.deployed();

    // Get all 20 accounts generated by Hardhat
    let accounts;
    accounts = await ethers.getSigners();

    // Loop through all the accounts, give each one 1 NFT + delegate so they get voting power
    for(let a=0; a<accounts.length; a++){
        await membershipNFT.safeMint(accounts[a].address);
        await membershipNFT.connect(accounts[a]).delegate(accounts[a].address);
    }
}

/**
 * Function entirely for testing purposes (not used in production)
 * Creates 10 fake proposal objects to use in testing
 * All proposal data stored in the Governance contract
 * @returns {Promise<Array[]>} - Array of Proposal IDs
 */
async function generateMockProposals() {
    let proposalIDs = [];

    // Get an instance of our Governance contract
    const gov = await ethers.getContractAt("Governance", "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0");
    await gov.deployed();

    //Get an instance of our UDAO Token contract
    const tokenAddress = '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512'
    const token = await ethers.getContractAt('ERC20', tokenAddress);

    //Data to feed into our propose() function for hashing
    const teamAddress = '0x70997970C51812dc3A010C7d01b50e0d17dc79C8';
    const grantAmount = 10;
    const transferCalldata = token.interface.encodeFunctionData('transfer', [teamAddress, grantAmount]);

    //Create 10 mock proposals and push the IDs of each one into an array
    for (let i=0; i<10; i++) {
        const proposal = await gov.propose([tokenAddress], [i], [transferCalldata], "Hash goes here");
        const receipt = await proposal.wait();

        const proposalID = await receipt.events[0].args.proposalId;
        proposalIDs.push(proposalID);
    }
    //Return our array of ProposalIDs
    return proposalIDs;
}

/**
 * Function entirely for testing purposes (not used in production)
 * Simulates a voting environment to test voting functionality with ethers
 * At each of the 10 Proposals passed in, each of the 20 Hardhat
 *  accounts will vote once.
 * After all is done, every proposal should have 20 randomized votes 
 *  that are either yes or no (for or against)
 * @param {Array[]} proposalIds - Array of Proposal IDs that we want to vote for
 */
async function simulateVoting(proposalIds) {
    // Get an instance of our Governance contract
    const gov = await ethers.getContractAt("Governance", "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0");
    await gov.deployed();

    // Get all 20 accounts generated by Hardhat
    let accounts;
    accounts = await ethers.getSigners();

    let support, vote, receipt;

    // At every Proposal ID, all 20 accounts vote (doubly nested for loop)
    for(let p=0; p<proposalIds.length; p++){
        console.log(`Now Voting on ProposalID: ${proposalIds[p]}`);
        for(let a=0; a<accounts.length; a++){

            //Generate a random number signifying the vote, 0 for no, 1 for yes
            support = Math.round(Math.random());
            console.log(`   Account ${accounts[a].address} will vote ${support} for the proposal.`);
            
            //Cast vote and grab receipt
            vote = await gov.connect(accounts[a]).castVote(proposalIds[p], support);
            receipt = await vote.wait();

            console.log(`       Vote of ${receipt.events[0].args[2]} completed.`);
            console.log(`           Proposal Data after vote: ${await gov.proposalVotes(proposalIds[p])}`);
        }
    }
}

/**
 * Given an array argument of Proposal IDs,
 * create a new proposal object array containing the ID
 * of each proposal + the vote data for that proposal
 * @param {Array[]} proposalIds - Array of Proposal ID values (uint256 values)
 * @returns {Promise<Array[]>} - Array of proposal objects
 */
 async function getBlockchainData(proposalIds) {
    let proposals = [];

    // Get an instance of our Governance contract
    const gov = await ethers.getContractAt("Governance", "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0");

    // Create our own proposal objects with ID + vote counts
    let votes;
    for(let i=0; i<proposalIds.length; i++){
        votes = await gov.proposalVotes(proposalIds[i]);
        proposals.push({
            id: proposalIds[i],
            votes: votes    
        });
    }

    //Return all vote data
    return proposals;
}

async function main() {
    await mintAndDelegate();
    let proposalIds = await generateMockProposals();
    await simulateVoting(proposalIds);
    let props = await getBlockchainData(proposalIds);
    console.log(props);
}

main();
